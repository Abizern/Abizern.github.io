#+HUGO_BASE_DIR: ./
#+options: author:nil
#+MACRO: marginnote @@html:{{<marginnote>}}$1{{</marginnote>}}@@
#+MACRO: sidenote @@html:{{<sidenote>}}$1{{</sidenote>}}@@

# These are used in the Talks section
#+MACRO: speakerdeck @@html:{{<marginnote>}}[Slides on Speaker Deck]($1){{</marginnote>}}@@
#+MACRO: skillsmatter @@html:{{<marginnote>}}[Video at Skills Matter]($1) (free login required){{</marginnote>}}@@
#+MACRO: youtube @@html:{{<marginnote>}}[Video on YouTube]($1){{</marginnote>}}@@

* Posts
** Advent of Code Day19: Linen Layout :advent_of_code:swift:
:PROPERTIES:
:EXPORT_FILE_NAME: aoc-day19-linen-layout
:EXPORT_DATE: 2024-12-19
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :meta true :math false
:END:
#+begin_description
Another simple day. Did it fast, then left it alone
#+end_description

My worries for today's{{{sidenote(https://adventofcode.com/2024/day/19)}}} puzzle being very difficult were unfounded. Which makes me more concerned for the weekend.

We are supposed to find the number of towel patterns that are possible given a set of small towels, and then we are supposed to count the number that can be created.

This is an application of the Change-making problem{{{sidenote(https://en.wikipedia.org/wiki/Change-making_problem)}}}.

*** Part 1
I made a recursive function which worked, but slowly, so I added a cache to it.

#+begin_src swift
  func isValid(_ target: String, from sources: [String], cache: inout [String: Bool]) -> Bool {
    if target.isEmpty { return true }
    if let cached = cache[target] { return cached }

    let candidates = sources.filter { target.hasPrefix($0) }.map(\.count)
    guard !candidates.isEmpty else {
      return false
    }
    for length in Set(candidates) {
      let newTarget = String(target.dropFirst(length))
      if isValid(newTarget, from: sources, cache: &cache) {
        cache[newTarget] = true
        return true
      } else {
        cache[newTarget] = false
      }
    }
    return false
#+end_src

The cache tracks whether towel (and sub-towel) combinations are valid or invalid. Along with the case for the target string remaining empty, this is the base case for the recursive function. If the target string is empty, we have been able to consume it's pattern with what is available, so it is valid.

If none of the available sources are a prefix of the towel, then it's not valid

If there are matches, then I remove the number of characters of the source pattern from the target pattern and continue the search. There is some cacheing along the way.

#+begin_src swift
  func part1() async throws -> Int {
    var cache: [String: Bool] = [:]
    let (sources, targets) = input
    return targets.map { isValid($0, from: sources, cache: &cache) }.filter { $0 }.count
  }
#+end_src


*** Part 2
Almost exactly the same as the first part, except we are counting what can be made:

#+begin_src swift
  func countMatches(_ target: String, from sources: [String], cache: inout [String: Int]) -> Int {
    if target.isEmpty { return 1 }
    if let cached = cache[target] { return cached }

    let candidates = sources.filter { target.hasPrefix($0) }
    guard !candidates.isEmpty else {
      return 0
    }

    var counts = 0
    for candidate in candidates {
      let newTarget = String(target.dropFirst(candidate.count))
      let count = countMatches(newTarget, from: sources, cache: &cache)
      if count > 0 {
        cache[newTarget] = count
        counts += count
      } else {
        cache[newTarget] = 0
      }
    }

    return counts
  }
#+end_src

Whenever the base case is reached, I return 1.

While searching, I recurse on the shortened target. In Part 1 I used a set of source lengths, to not duplicate any searches, but in this case it was easier to kick off one call for each match to make consolidating the results faster. And let the cache deal with the multiple calls.

#+begin_src swift
  func part2() async throws -> Int {
    var cache: [String: Int] = [:]
    let (sources, targets) = input
    return targets.map { countMatches($0, from: sources, cache: &cache) }.reduce(0, +)
  }
#+end_src

*** Final Thoughts
It took less than 0.1s for each part and I think that's good enough.

As usual, the full source is available on Github{{{sidenote(https://github.com/Abizern/aoc-swift-2024/blob/main/Sources/Day19.swift)}}}.

I still have some left-over challenges to finish and I should work on them rather than tidy this up to be better code. Yes, there is repetition, but that doesn't bother me as much as it seems to for other people. For more, see my Ted talk on why DRY is a scam{{{sidenote(There is no talk\, but I do think excessive application of DRY may lead to unwanted coupling)}}}.

I'm giving myself permission to slack off on this one.

** Advent of Code Day18: RAM Run                    :advent_of_code:swift:
:PROPERTIES:
:EXPORT_FILE_NAME: aoc-day18-ram-run
:EXPORT_DATE: 2024-12-18
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :meta true :math false
:END:
#+begin_description
Did it fast, and then did it well.
#+end_description

I enjoyed today's puzzle{{{sidenote(https://adventofcode.com/2024/day/18)}}}.Not because it was reasonably easy, but because I managed to grind out a reasonable efficient solution after thinking about the problem for a little bit. This gave me as much satisfaction as when I figured out the Lanternfish{{{sidenote(The Lanternfish from 2021 https://adventofcode.com/2021/day/6)}}} problem.

I also got to play with GameplayKit{{{sidenote(https://developer.apple.com/documentation/gameplaykit)}}} and Swift-algorithms{{{sidenote(https://github.com/apple/swift-algorithms)}}}.

*** Part 1
given a list of positions in a grid, we are supposed to find the shortest number of steps to go from one corner to another.

Unlike Reindeer Maze{{{sidenote(https://adventofcode.com/2024/day/16)}}}, this is a pure path finding problem. I don't need to implement the search myself{{{sidenote(Not wanting to do this myself is one of the reasons I haven't even started solving Day 16 yet)}}}, I can just use the built in methods from GameplayKit.

#+begin_src swift
  func part1() async throws -> String {
    let graph = createGraph(width: 71, height: 71)
    let points = points.prefix(1024)
    remove(points: points, from: graph)

    let start = graph.node(atGridPosition: vector_int2(0, 0))!
    let end = graph.node(atGridPosition: vector_int2(70, 70))!

    let path = graph.findPath(from: start, to: end)

    return "\(path.count - 1)" // steps, is one less than length of path
  }
#+end_src

The full code{{{sidenote(https://github.com/Abizern/aoc-swift-2024/blob/main/Sources/Day18.swift)}}} has more context around the helper functions, but this is quite simple:

I create a =GKGridGraph= of the specified size, take the first 1024 points off my input list and remove those nodes from the graph. The =GKGridGraph= class takes care of creating a graph for all the remaining nodes, connecting them to their nearest neighbours. Removing nodes leaves me with graph of what cells are connected.

The =FindPath(from:to:)= method returns a list of the nodes traversed in the shortest path from start to end, and I subtract 1 from that as steps are the transitions between paths.

That was that. As usual I tried to get Part 1 as quickly as possible so I can get on to part 2.

*** Part 2
Now we have to use the full input list of points and find which one completely closes off the end point from the start point.

**** Step 1: Brute Force

I wasn't sure if it would work in a reasonable amount of time, but it was quick to write so I gave it a try:

#+begin_src swift
  func bruteForce() -> String {
    let graph = createGraph(width: 71, height: 71)
    let start = graph.node(atGridPosition: vector_int2(0, 0))!
    let end = graph.node(atGridPosition: vector_int2(70, 70))!

    remove(points: points.prefix(1024), from: graph)

    for point in points.dropFirst(1024) {
      let node = graph.node(atGridPosition: vector_int2(Int32(point.1), Int32(point.0)))!
      graph.remove([node])

      if graph.findPath(from: start, to: end).isEmpty {
        return "\(point.0),\(point.1)"
      }
    }

    return "Anser not found"
  }
#+end_src

I create a graph, and the start and end points and then remove the first 1024 points from the graph. I know this doesn't disconnect the start and end because I've already worked out how many steps it takes.

Then, I remove one node at a time and see if a path exists, still using the =findPath(from:to:)= method.

This ran in 23s on my machine. Which is okay, but not really what I am looking for.

**** Stejp 2: Binary Search
Searching for the path is what takes time, so it is a good idea to reduce the number of times we have run that bit of code.

Since the list is ordered, the nodes are removed one at a time in a sequence, A binary search can be used instead.

If you don't know what a binary search{{{marginnote(This is a simple explanation of a binary search\, I first heard it in a Colombo episode and it has always stayed with me.)}}} is, let me give you an example. You have a large number of small bags of gold and a weighing machine that charges you each time you use it. Each of the bags has 10 gold coins in it of equal weight, except, one bag has 9 gold coins and a lead coin that weights slightly _less_ than the gold ones. You want to spend as little as possible on weighing scale charges{{{marginnote(I don't know why; you have all this gold around you.)}}} so you can't jest weigh each bag. Instead you split them into two piles. You weight the first one and then the second pile. One of these piles will weigh less than the other{{{assuming an even number of bags. If it's an odd number, you split  them into even piles, and if they both weight the same, then the left over one is the bag you are looking for.}}} so you know that one of those bags is the one you are looking for. You split this pile into two and weight both piles, again, looking for the lighter pile. This is the process: just keep splitting in two and working on the pile that is lightest. This is obviously going to be faster than weighing each bag. And cheaper.

The swift-algorithms package has a method on arrays called =partioningIndex= which takes a predicate that you provide to show whether the element belongs in the first half or the second half of each shortened list. And it returns the index of the first item where that predicate returns true.

My solution looks like this:

#+begin_src swift
  func binarySearch() -> String {
    let index = points.partitioningIndex { point in
      let graph = createGraph(width: 71, height: 71)
      let start = graph.node(atGridPosition: vector_int2(0, 0))!
      let end = graph.node(atGridPosition: vector_int2(70, 70))!
      let searchIndex = points.firstIndex { $0 == point }!
      let slice = points.prefix(through: searchIndex)
      remove(points: slice, from: graph)

      return graph.findPath(from: start, to: end).isEmpty
    }

    let point = points[index]

    return "\(point.0),\(point.1)"
  }
#+end_src

Within the predicate, I create a graph, remove all the nodes up to and including the point being examined, and see if a path can be found to the end point. This does the search for me. I use the returned index to get the value to use as the result.

This runs faster, about 13s. This is okay, but I was sure I could do better.

**** Part 3 Obstacle based search.
I want to minimise the number of times I have to look for a path. And I had that moment of clarity that, as programmers, makes us feel as if we are doing what we were meant to do.

#+begin_src swift
  func obstacle() -> String {
    let graph = createGraph(width: 71, height: 71)
    let start = graph.node(atGridPosition: vector_int2(0, 0))!
    let end = graph.node(atGridPosition: vector_int2(70, 70))!

    remove(points: points.prefix(1024), from: graph)
    var path = graph.findPath(from: start, to: end)

    for point in points.dropFirst(1024) {
      let node = graph.node(atGridPosition: vector_int2(Int32(point.1), Int32(point.0)))!
      graph.remove([node])

      guard path.contains(node) else { continue }

      let newPath = graph.findPath(from: start, to: end)

      if newPath.isEmpty {
        return "\(point.0),\(point.1)"
      } else {
        path = newPath
      }
    }

    return "Answer not found"
  }
#+end_src

I set up the graph, start and end points as usual, and remove the first 1024 nodes from the input. I know that a path exists at this point, so I cache it in the =path= variable.

Now I go through the remaining points one by one, just as with the brute force search, _except_ if the node to be removed is not one of the nodes on the shortest path, it isn't going to change anything. So I just remove the node and check the next node to remove. If you have a path and the node being taken away is not on that path, there is no need to recalculate the path. I still remove it, because If I do have to search for another path, it's important that it is not included.

If the node is on the path, then I remove the node and search for the path again, cacheing the result in the same variable.

I do this until I find a node to remove that is on the path, and the new recalculated path does not exist.

This runs an just over 1s. I can live with that.

*** General Progress.
I'm behind in my solutions, but I'm up to date with my notes. I still have Day 16 to do and the second part of Day17. But I'll get around to them when I can.

My notes are out of order, but I don't think that matters and I don't want to be held up by wanting to write them in order.

I'm a little concerned about tomorrow. Today was reasonably easy to just get an answer. There might be some terrors yet to come.

** Advent of Code Day15: Warehouse Woes               :advent_of_code:swift:
:PROPERTIES:
:EXPORT_FILE_NAME: aoc-day15-warehouse-woes
:EXPORT_DATE: 2024-12-17
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :meta true :math false
:END:
#+begin_description
Sometimes this feels like work
#+end_description

I actually got this{{{sidenote(https://adventofcode.com/2024/day/15)}}} done on the day, but haven't written it up because I'm not too happy with the way I got to my solution{{{sidenote(https://github.com/Abizern/aoc-swift-2024/blob/main/Sources/Day15.swift)}}}.

I'm not a fan of problems like this. You have a map and a process; it's just a case of writing out the process. Very much like the day job of a programmer - here's the current system, here are the new requirements: get on with it. At least with AoC I don't have to have my code pass anyone's review.

For some reason my parsing code wasn't working and I spent too long trying to debug that rather than just getting on with it. I ended up with a hybrid solution of splitting the input into two parts and then running parsers over each part.

We are supposed to take a map of the warehouse and a list of moves and then just process these moves over the grid.

A couple of things to note: Firstly, because the map is surrounded by walls, checking that points are within bounds are a lot easier. Any point you are at will get you 4 neighbours. Some of them may be wall tiles, but they will be valid entries on the grid. Secondly, things only move by one space, which makes checking valid moves easier.

*** Part 1
There really isn't much to this. I ended up with a recursive function:

#+begin_src swift
  func move(
    _ state: ((Int, Int), [[Character]]),
    dir: Character,
    tip: (Int, Int)? = nil,
    boxes: [(Int, Int)] = []
  ) -> ((Int, Int), [[Character]]) {
    var ((r, c), rows) = state

    let dr: Int
    let dc: Int

    switch dir {
    case "^": (dr, dc) = (-1, 0)
    case ">": (dr, dc) = (0, 1)
    case "v": (dr, dc) = (1, 0)
    case "<": (dr, dc) = (0, -1)
    default: fatalError("Unknown direction \(dir)")
    }

    let (nr, nc) = tip ?? (r + dr, c + dc)
    let candidate = rows[nr][nc]

    if candidate == "#" {
      return state
    } else if candidate == "." {
      for box in boxes {
        rows[box.0 + dr][box.1 + dc] = "O"
      }
      rows[r][c] = "."
      (r, c) = (r + dr, c + dc)
      rows[r][c] = "@"
      return ((r, c), rows)
    } else { // candidate = "O"
      let newTip = (nr + dr, nc + dc)
      let newBoxes = boxes + [(nr, nc)]
      return move(state, dir: dir, tip: newTip, boxes: newBoxes)
    }
  }
#+end_src

I keep track of the tip of my search path, in whatever direction I am going and there are three conditions:

The tile is a wall: Nothing moves and I just return the original state of the map.

The tile is a space: I set the robot tile to ".", set the next tile in the given direction to "@" as the robot has moved, and then I take the pile of boxes that I've collected{{{sidenote(See the next condition, which is where they get populated)}}} and move them one position up in the given direction.

If the tile contains a box, this is the recursive case, I add it's position to the running =boxes= variable. This is what tracks all the boxes that have to be moved. and then move the tip (which is the next search tile) in the given direction. And I start again.

Since the whole, single width, stack is moving, I don't need to worry about resetting any empty tiles, because everything moves.

*** Part 2

With a bigger map, and a different way of handling boxes.

Horizontal moves are handled almost exactly the same way as with part 1, except now I keep track of the character than I am moving as well as its position.

#+begin_src swift
  func moveHorizontally(_ state: (Cell, [[Character]]), hOffset: Int, nextPos: Cell, boxes: [Cell: Character]) -> (Cell, [[Character]]) {
    var (robot, rows) = state
    var boxes = boxes
    let candidate = rows[nextPos.row][nextPos.col]

    guard candidate != "#" else {
      return state
    }

    if candidate == "." {
      for (key, value) in boxes {
        rows[key.row][key.col + hOffset] = value
      }
      rows[robot.row][robot.col] = "."

      rows[robot.row][robot.col + hOffset] = "@"
      return (Cell(robot.row, robot.col + hOffset), rows)
    }

    if candidate == "[" || candidate == "]" {
      boxes[nextPos] = candidate
      let newNextPos = Cell((nextPos.row, nextPos.col + hOffset))

      return moveHorizontally(state, hOffset: hOffset, nextPos: newNextPos, boxes: boxes)
    }

    fatalError("We should have handled something by now.")
  }
#+end_src

For vertical moves I have to handle things a little differently: Rather than a single point being the "tip" of the search, it can be a row, which is everything connected to the robot.

#+begin_src swift
  func moveVertically(_ state: (Cell, [[Character]]), vOffset: Int, nextPos: [Cell], boxes: [Cell: Character]) -> (Cell, [[Character]]) {
    var (robot, rows) = state
    var boxes = boxes
    let candidates = nextPos.map { rows[$0.row][$0.col] }

    if candidates.contains("#") {
      return state
    }

    if candidates.allSatisfy({ $0 == "." }) {
      for (key, _) in boxes {
        rows[key.row][key.col] = "."
      }
      for (key, value) in boxes {
        rows[key.row + vOffset][key.col] = value
      }
      rows[robot.row][robot.col] = "."
      rows[robot.row + vOffset][robot.col] = "@"
      return (Cell(robot.row + vOffset, robot.col), rows)
    }

    if candidates.contains("[") || candidates.contains("]") {
      var candidateBoxes = nextPos.map { ($0, rows[$0.row][$0.col]) }.sorted { $0.0.col < $1.0.col }

      if let lst = candidateBoxes.last, lst.1 == "[" {
        let (rightRow, rightCol) = (lst.0.row, lst.0.col + 1)
        candidateBoxes.append((Cell((rightRow, rightCol)), rows[rightRow][rightCol]))
      }

      if let fst = candidateBoxes.first, fst.1 == "]" {
        let (leftRow, leftCol) = (fst.0.row, fst.0.col - 1)
        candidateBoxes.append((Cell((leftRow, leftCol)), rows[leftRow][leftCol]))
      }

      var newNextPos: [Cell] = []
      for (cell, value) in candidateBoxes {
        if value == "[" || value == "]" {
          boxes[cell] = value
          newNextPos.append(Cell((cell.row + vOffset, cell.col)))
        }
      }

      return moveVertically(state, vOffset: vOffset, nextPos: newNextPos, boxes: boxes)
    }

    fatalError("We should have matched something by now")
  }
#+end_src

I have to handle the ends of this row a little differently since boxes are in two parts. That's what the sorting and checking code is. I sort my list of moving candidates, if the leftmost point is "]" I know there is a "[" to it's left, and if there is a "[" at the right, then there is a "]" one cell over.

The same recursive process applies.

Another difference is that I over wrote every visited tile with "." before moving the boxes to their new positions, because, unlike the horizontal case, not every position will be overwritten bi a new box or a robot.

I then run these two recursive functions from a single non-recursive function:

#+begin_src swift
  func wideMove(_ state: (Cell, [[Character]]), dir: Character) -> (Cell, [[Character]]) {
    let (r, c) = (state.0.row, state.0.col)

    switch dir {
    case "^":
      let vOffset = -1
      return moveVertically(state, vOffset: vOffset, nextPos: [Cell((r + vOffset, c))], boxes: [:])
    case "v":
      let vOffset = 1
      return moveVertically(state, vOffset: vOffset, nextPos: [Cell((r + vOffset, c))], boxes: [:])
    case ">":
      let hOffset = 1
      return moveHorizontally(state, hOffset: hOffset, nextPos: Cell((r, c + hOffset)), boxes: [:])
    case "<":
      let hOffset = -1
      return moveHorizontally(state, hOffset: hOffset, nextPos: Cell((r, c + hOffset)), boxes: [:])
    default:
      fatalError("Unknown direction \(dir)")
    }
  }
#+end_src

And that was it.

One of the only things that I managed to take from this was that I really thought about the recursive solution to part 2 and my code ran and gave me the correct answer at the first attempt. Unfortunately, I was a little sick of it by the time I'd finished that I can't bring myself to go back and tidy it up. Maybe I'll go back and tidy it up at some later date.

** Advent of Code Day14: Restroom Redoubt             :advent_of_code:swift:
:PROPERTIES:
:EXPORT_FILE_NAME: aoc-day14-restroom-redoubt
:EXPORT_DATE: 2024-12-14T14:30:00Z
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :meta true :math false
:END:
#+begin_description
Easter Eggs in a Christmas themed puzzle?
#+end_description

I think this{{{sidenote(https://adventofcode.com/2024/day/14)}}} was a short one because part2 wasn't the easiest to come up with a definitive answer.

*** Part 1
I think I'm getting better with parsing inputs, I got this into my system quickly and the rest of it was just writing a simulation for 100 iterations, counting locations and figuring out the safety score.

It probably isn't worth putting the code itself here, but it's available{{{sidenote(https://github.com/Abizern/aoc-swift-2024/blob/main/Sources/Day14.swift)}}} on Github.

*** Part 2
No way to write a test for this, and I wasn't going to cycle through all the possibilities to look for a tree. And there wasn't a description of the tree. Thinking it could have something to do with the solution to part 1, I looked at varies points, if any quadrants we empty, or symmetric, but it turned out that finding the *minimum of the safety score*, is the answer. You can see the output of my tree{{{sidenote([aoc-tree.txt](/img/2024/12/aoc-tree.txt))}}} as a text file.

** Advent of Code Day13: Claw Contraption             :advent_of_code:swift:
:PROPERTIES:
:EXPORT_FILE_NAME: aoc-day13-claw-contraption
:EXPORT_DATE: 2024-12-14T13:30:00Z
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :meta true :math true
:END:
#+begin_description
The claw has chosen...
#+end_description

I went on a bit of a math rabbit hole, but came up with a solution that runs quickly enough.

This one is just about maths. We have a machine with buttons to move a claw{{{sidenote(https://adventofcode.com/2024/day/13)}}} and want to know a) can it be positioned in a particular place, and b) if it can be positioned, how much will it cost.

*** Part 1
We are told that the machine should take no more than 100 button presses to move the claw. As I like to get the first part done quickly so that I can get to the second part, I wrote a brute for solution that just ran through 100 button presses until I found an answer.

#+begin_src swift
  var minimumCost: Int? {
    var minimumCost: Int?
    for a in 0 ..< 100 {
      for b in 0 ..< 100 {
        let currentX = a * buttonA.dx + b * buttonB.dx
        let currentY = a * buttonA.dy + b * buttonB.dy

        if currentX == prize.x, currentY == prize.y {
          let cost = 3 * a + b
          if minimumCost == nil || cost < minimumCost! {
            minimumCost = cost
          }
        }
      }
    }
    return minimumCost
  }
#+end_src

Even for all of the inputs, this hardly took any time. I'm not sure I even needed to worry about the minimum cost, these are straight line equations and will only have one solution.

Running the solution was a one liner.

#+begin_src swift
  func part1() async throws -> Int {
    machines.compactMap(\.costToWin).reduce(0, +)
  }
#+end_src

*** Part 2
With the target positions set to large numbers, this brute force method was not going to be feasible.

We have two equations linear equations

\[
a_x m + b_x n = c_x \quad (1) \\
a_y m + b_y n = c_y \quad (2)
\]

where:
- \(a_x\) and \(b_x\) are the distances moved in the \(x\) direction by the \(a\) and \(b\) buttons.
- \(a_y\) and \(b_y\) are the distances moved in the \(y\) direction by the \(a\) and \(b\) buttons.
- \(c_x\) and \(c_y\) are the distances in the \(x\) and \(y\) direction to the target.

These are simultaneous equations that could be solved mathematically many ways, direct substitution, matrix methods, etc. But we know that these are Linear Diophantine{{{sidenote(https://en.wikipedia.org/wiki/Diophantine_equation#:~:text=In%20mathematics%2C%20a%20Diophantine%20equation,integer%20solutions%20are%20of%20interest.)}}} equations, that have whole number solutions, and I didn't want to use numerical methods that deal with Real numbers.

I thought about using the Chinese Remainder Theorem{{{sidenote(https://en.wikipedia.org/wiki/Chinese_remainder_theorem)}}}, but for only two equations I didn't want to go turning them into modular forms.

But there is the Extended Euclidean Algorithm{{{sidenote(https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm)}}} which deals with equations of the form we are given, so I tried to use that.

But since there are two equations, I didn't need to go that far, there are only a couple of checks that need to be done. Essentially the code to solve this returns a tuple of the number of presses required for A and B, or nil if there is no solution.

#+begin_src swift
  public func diophantineEEA(ax: Int, bx: Int, ay: Int, by: Int, cx: Int, cy: Int) -> (m: Int, n: Int)? {
  let aPrime = ay * bx - by * ax
  let cPrime = cy * bx - by * cx

  if aPrime == 0 || cPrime % aPrime != 0 {
    return nil
  }

  let m = cPrime / aPrime

  let numerator = cx - ax * m
  if numerator % bx != 0 {
    return nil
  }

  let n = numerator / bx

  return (m, n)
}
#+end_src

We can rearrange \((1)\) so that there is only one variable on the left:

\[
n = \frac{c_x - a_xm}{b_x} \quad (3)
\]

Substitute this value of n into \((2)\):

\[ a_y m + b_y \left( \displaystyle \frac{c_x - a_x m}{b_x} \right) = c_y \quad (4) \]

With a little re-arrangement and distribution{{{marginnote(Left as an exercise for the reader.)}}} this can be re-written as:

\[ (a_y b_x - b_y a_x) m = c_y b_x - b_y c_x \quad (5) \]

We can simplify this as:

\[ a' = a_y b_x - b_y a_x , c' = c_y b_x - b_y c_x  \quad (6) \]

And we are left with:

\[ a'm = c' \quad (7) \]

This is where the conditions for Diophantine equations apply. obviously \[a'\] can't be zero, and \[c' / a' \] has to be a whole number. Since presses can only be whole numbers, \[m\] and \[n\] have to be whole numbers.

The rest is just substitution.

#+begin_src swift
  var costToWin: Int? {
    guard let (a, b) = diophantineEEA(
            ax: buttonA.dx,
            bx: buttonB.dx,
            ay: buttonA.dy,
            by: buttonB.dy,
            cx: prize.x,
            cy: prize.y
          )
    else {
      return nil
    }
    return 3 * a + b
  }

  func part2() async throws -> Int {
    machines.map(\.corrected).compactMap((\.costToWin)).reduce(0, +)
  }
#+end_src

This runs really quickly. Not sure I needed to spend the time learning how to make sure the answers are whole numbers, but that's one of the reasons I do AoC -- to learn new things.

As usual, the full code{{{sidenote(https://github.com/Abizern/aoc-swift-2024/blob/main/Sources/Day13.swift)}}} is on Github.


** Advent of Code Day12: Garden Groups                :advent_of_code:swift:
:PROPERTIES:
:EXPORT_FILE_NAME: aoc-day12-garden-groups
:EXPORT_DATE: 2024-12-13T04:50:00Z
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :meta true :math false
:END:
#+begin_description
I see flood fills everywhere.
#+end_description

Today's challenge{{{sidenote(https://adventofcode.com/2024/day/12)}}} felt very strange to me. I read the question. I knew what I had to do for Part 1, but I didn't feel very motivated to actually finish my implementation. I pushed through and eventually got it done, then spent too long thinking about how to do Part 2 before I realised that it was more or less the same approach as for part 1, just with different parameters.

*** Part 1
Given a grid of a farm and its crops we are supposed to work out some number based on the area and the perimeter.

The approach I used was that of flood filling. I take a point from the graph and do a search for all its neighbours that have the same crop type, and I keep doing that until I have found all connected plots of the same type. I keep track of the plots that I have seen so I don't double count them, and do this for all the plots.

Counting the number of plots in each region gives me the area.

Since I was using GameplayKit to help me with my graph, I went through and removed all edges that weren't connected to a plot of the same type. For each plot I then work out the number of sides by subtracting the number of graph edges it has to other plots from 4. Then multiply and sum to get the first answer.

#+begin_src swift
extension Day12 {
  typealias GridGraph = GKGridGraph<GKGridGraphNode>
  typealias Node = GKGridGraphNode

  func farm(from rows: [[Character]]) -> GridGraph {
    let width = Int32(rows[0].count)
    let height = Int32(rows.count)
    let origin = vector_int2(0, 0)
    let graph = GKGridGraph(
      fromGridStartingAt: origin,
      width: width,
      height: height,
      diagonalsAllowed: false,
      nodeClass: Node.self
    )

    for node in graph.nodes! {
      let node = node as! Node
      let position = node.gridPosition
      let (row, column) = (Int(position.y), Int(position.x))

      for neighbor in node.connectedNodes {
        let neighbor = neighbor as! Node
        let nPosition = neighbor.gridPosition
        let (nRow, nColumn) = (Int(nPosition.y), Int(nPosition.x))

        if rows[nRow][nColumn] != rows[row][column] {
          node.removeConnections(to: [neighbor], bidirectional: true)
        }
      }
    }

    return graph
  }

  func regions(from graph: GridGraph, rows _: [[Character]]) -> [Set<Node>] {
    var regions: [Set<Node>] = []
    var seen: Set<Node> = []

    for node in graph.nodes! {
      let node = node as! Node
      guard !seen.contains(node) else { continue }

      var stack = [node]
      var currentRegion = Set<Node>()

      while !stack.isEmpty {
        let currentNode = stack.removeLast()
        guard !seen.contains(currentNode) else { continue }
        seen.insert(currentNode)
        currentRegion.insert(currentNode)

        // Add unvisited neighbors of the same region to the stack
        for neighbor in currentNode.connectedNodes {
          let neighbor = neighbor as! Node
          if !seen.contains(neighbor) {
            stack.append(neighbor)
          }
        }
      }

      if !currentRegion.isEmpty {
        regions.append(currentRegion)
      }
    }

    return regions
  }

  func price(_ region: Set<Node>) -> Int {
    let area = region.count
    let perimeter = region.reduce(0) { partialResult, node in
      partialResult + 4 - node.connectedNodes.count
    }

    return area * perimeter
  }
}
#+end_src

*** Part 2
This took a lot more thought before I bit the bullet and wrote the code.

I defined a struct to represent and edge for a plot:

#+begin_src swift
 struct Edge: Hashable {
    enum Direction: Hashable {
      case top, right, bottom, left
    }

    let position: vector_int2
    let direction: Direction

    var neighbours: [Edge] {
      let x = position.x
      let y = position.y
      switch direction {
      case .top, .bottom:
        return [
          Edge(position: vector_int2(x: x + 1, y: y), direction: direction),
          Edge(position: vector_int2(x: x - 1, y: y), direction: direction),
        ]
      case .right, .left:
        return [
          Edge(position: vector_int2(x: x, y: y + 1), direction: direction),
          Edge(position: vector_int2(x: x, y: y - 1), direction: direction),
        ]
      }
    }
  }
#+end_src

This also gives me the neighbours I expect to have in horizontal and vertical directions.

I already have a function for working out a connected region, and I use that to generate all the plot edges:

#+begin_src swift
  func edges(for region: Set<Node>) -> Set<Edge> {
    var edges: Set<Edge> = []

    for node in region {
      let position = node.gridPosition
      let above = position.above
      let below = position.below
      let left = position.left
      let right = position.right

      let neighbours = node.connectedNodes.map { $0 as! Node }.map(\.gridPosition)
      if !neighbours.contains(above) {
        edges.insert(Edge(position: position, direction: .top))
      }

      if !neighbours.contains(below) {
        edges.insert(Edge(position: position, direction: .bottom))
      }

      if !neighbours.contains(left) {
        edges.insert(Edge(position: position, direction: .left))
      }

      if !neighbours.contains(right) {
        edges.insert(Edge(position: position, direction: .right))
      }
    }
    return edges
  }
#+end_src

Now I use the same flood filling to find all the connected edges. I take an edge off the list, and generate it's expected neighbours and count them up.

#+begin_src swift
  func sides(for region: Set<Node>) -> Int {
    let edges = edges(for: region)
    var totalSides = 0
    var seen = Set<Edge>()

    for edge in edges {
      guard !seen.contains(edge) else { continue }
      var stack = Deque<Edge>([edge])

      while !stack.isEmpty {
        let current = stack.removeFirst()
        guard !seen.contains(current) else { continue }
        seen.insert(current)

        for neighbour in current.neighbours {
          guard !seen.contains(neighbour) else { continue }
          if edges.contains(neighbour) {
            stack.append(neighbour)
          }
        }
      }

      totalSides += 1
    }
    return totalSides
  }
#+end_src

And that gave me the correct answer.

As usual, the full code for this is on Github{{{sidenote(https://github.com/Abizern/aoc-swift-2024/blob/main/Sources/Day12.swift)}}}. It felt like a slog, I don't mind telling you.

** Advent of Code Day11: Plutonian Pebbles            :advent_of_code:swift:
:PROPERTIES:
:EXPORT_FILE_NAME: aoc-day11-plutonian-pebbles
:EXPORT_DATE: 2024-12-11
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :meta true :math false
:END:
#+begin_description
I've seen this type of problem before
#+end_description

Today{{{sidenote(https://adventofcode.com/2024/day/11)}}} we had a list of stones that changed over time and we had to count how many there would be at the end of the count. I thought this sort of problem would come up, I've seen it before{{{sidenote(The Lanternfish from 2021 https://adventofcode.com/2021/day/6)}}}, and it is one of my favourite ones because it was the first time I saw the process for solving these puzzles.

The problem is that with the splitting of the stones (or the spawning in the case of lanternfish) the number of stones starts going up very quickly, though their identifying numbers lie mostly within a smaller range. In the case of lanternfish it was the number of days in the cycle, for the stones it today's puzzle, it is the identifier.

For odd length numbers, this index goes up to larger numbers, which will probably need to split into two stones in the following cycle. Eventually, these identifiers will start to appear multiple times, which is the clue to the process for solving these puzzles: We can deal with blocks of stones (excuse the pun) sharing an ID in one step.

*** Part 1

I turned the input into a dictionary of identifiers and their counts from the input. There are no duplicates to start with.

#+begin_src swift
  var stoneDictionary: [Int: Int] {
    do {
      let numbers = try NumberLine(separator: " ").parse(data)
      return Dictionary(grouping: numbers, by: { $0 }).mapValues(\.count)
    } catch {
      fatalError("Could not parse input \(error)")
    }
  }
#+end_src

The main engine of the solution is the function with processes the list of stones: in my case a dcitionary

#+begin_src swift
  func step(_ dict: [Int: Int]) -> [Int: Int] {
    var keys = dict.keys.filter { $0 != 0 }.map { ($0, String($0)) }
    let partitionIndex = keys.partition { $0.1.count % 2 == 1 }
    var accum = [Int: Int]()

    if let zeroes = dict[0] {
      accum[1] = zeroes
    }

    // even length keys
    for pair in keys[0 ..< partitionIndex] {
      let (key, strKey) = pair
      let count = dict[key]!
      let midpoint = strKey.count / 2

      accum[Int(strKey.prefix(midpoint))!, default: 0] += count
      accum[Int(strKey.suffix(midpoint))!, default: 0] += count
    }

    for pair in keys[partitionIndex ..< keys.count] {
      let key = pair.0
      let newKey = key * 2024
      let value = dict[key]!

      accum[newKey, default: 0] += value
    }

    return accum
  }
#+end_src

Which looks long but is quite simple

Start by splitting the keys into a pair of the key and the string representation of the key. Then use the =partion(by:)= method on arrays, which rearranges an array such that elements which pass the predicate appear after elements that fail the predicate. The value returned is the index of the partion

#+begin_src swift
  var keys = dict.keys.filter { $0 != 0 }.map { ($0, String($0)) }
  let partitionIndex = keys.partition { $0.1.count % 2 == 1 }
#+end_src

I create a dictionary to hold the new state of the stones, and deal with those that have an identifier of 0 to have identifier's of 1
#+begin_src swift
  var accum = [Int: Int]()

  if let zeroes = dict[0] {
    accum[1] = zeroes
  }
#+end_src

For keys that have even length keys, I loop through them, performing the split to get the news keys and then adding the counts of those stones to the new dictionary.
#+begin_src swift
  for pair in keys[0 ..< partitionIndex] {
    let (key, strKey) = pair
    let count = dict[key]!
    let midpoint = strKey.count / 2

    accum[Int(strKey.prefix(midpoint))!, default: 0] += count
    accum[Int(strKey.suffix(midpoint))!, default: 0] += count
  }
#+end_src

For the odd length key, I multiply the key by =2024= ad assign the value to this keys in the new dictionary, and return the new state of the stones.
#+begin_src swift
  for pair in keys[partitionIndex ..< keys.count] {
    let key = pair.0
    let newKey = key * 2024
    let value = dict[key]!

    accum[newKey, default: 0] += value
  }

  return accum
#+end_src

To run this for a given number of blinks I created a helper function that iteratively runs the step function for a given number of times.

#+begin_src swift
  func stepper(_ dict: [Int: Int], blinks: Int) -> Int {
    var dict = dict
    for _ in 0 ..< blinks {
      dict = step(dict)
    }

    return dict.values.reduce(0, +)
  }
#+end_src

Running it for 25 times is easy enough now.

#+begin_src swift
  func part1() async throws -> Int {
    stepper(stoneDictionary, blinks: 25)
  }
#+end_src

*** Part 2
It may be possible to run the first part by applying the rules to one stone at a time for part 1, I remember from my attempts at Lanternfish that this takes a long time for step 2. Except it doesn't really.

Change the number of steps to 75 instead of 25, and it still runs in millisecond time.
#+begin_src swift
  func part2() async throws -> Int {
    stepper(stoneDictionary, blinks: 75)
  }
#+end_src

The full source, which is not much longer, is available on Github{{{sidenote(https://github.com/Abizern/aoc-swift-2024/blob/main/Sources/Day11.swift)}}}.


** Advent of Code Day10: Hoof It                      :advent_of_code:swift:
:PROPERTIES:
:EXPORT_FILE_NAME: aoc-day10-hoof-it
:EXPORT_DATE: 2024-12-10
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :meta true :math false
:END:
#+begin_description
Easier than expected, don't look a gift reindeer in the mouth.
#+end_description

I was expecting a Graph{{{sidenote(https://adventofcode.come/2024/day/9)}}} problem to show up around now, and it as a good time to create a utility =Grid= class to make working with these 2D graphs a little easier.

Unlike yesterday's{{{sidenote(https://abizern.dev/posts/aoc-day9-disk-fragmenter/)}}} debacle, I read the question carefully. I took care to only count one start -- end point as a route, which meant that part 2 was quite easy to do. I ended up refactoring both methods into one, but I'll show the original methods here because it might make for a clearer explanation

*** Part 1
My grid type takes care of returning neighbours of a point {{{sidenote(Which I represent with a Cell struct to refer to a point in a grid)}}} and only returning valid cells that are within bounds.

Given a staring position (which I find by looking for all the Cells with value 0) I calculate the score using:

#+begin_src swift
  func score(_ grid: Grid<Int>, start: Cell) -> Int {
    var count = 0
    var queue = Deque<Cell>([start])
    var ends = Set<Cell>()

    while !queue.isEmpty {
      let cursor = queue.removeFirst()

      guard let cursorValue = grid.element(cursor),
            cursorValue != 9
      else {
        if !ends.contains(cursor) {
          count += 1
          ends.insert(cursor)
        }
        continue
      }

      let neighbours = grid
        .neighbours(cursor, includeDiagonals: false)
        .filter { grid.element($0)! - cursorValue == 1 }
      queue.append(contentsOf: neighbours)
    }

    return count
  }
#+end_src

I set up some variables to track the count and the endpoints of each trailhead I also set up a queue to store the candidates to consider{{{sidenote(I did something similar for Day 4 https://abizern.dev/posts/aoc-day4-ceres-search/)}}}, and initialise it with the position of the start point.

Then go through the list, taking a value from it as long as there are values to be taken. Most loops will add a value to this list and it is how the routes are calculated.


#+begin_src swift
  let cursor = queue.removeFirst()
#+end_src

if the value is not an end point, get all the neighbours that have values that are strictly one more than the value of the current point and add them to the queue. Since the condition is looking for greater values, there is no need to worry about backtracking.

#+begin_src swift
  let neighbours = grid
    .neighbours(cursor, includeDiagonals: false)
    .filter { grid.element($0)! - cursorValue == 1 }
  queue.append(contentsOf: neighbours)
#+end_src

if the value is 9, we have reached the end of the trail

#+begin_src swift
  guard let cursorValue = grid.element(cursor),
        cursorValue != 9
  else {
    if !ends.contains(cursor) {
      count += 1
      ends.insert(cursor)
    }
    continue
  }  
#+end_src

We check whether we have already found the end point. The requirement is that we find the longest path, but the length doesn't matter as we are not doing anything with the length. If there are multiple paths, one of them is bound to be the longest. If I've found the path I just move on to the next cell in the list without incrementing the count.

Running the code to get the answer:

#+begin_src swift
  func part1() async throws -> Int {
    trailHeads(grid).map { score(grid, start: $0) }.reduce(0, +)
  }
#+end_src

*** Part 2
For the second part, there is no need to check if we have already considered the end point. We have to find all paths, and this is made easier by the requirement that the value is always increasing, so there are no loops.

The code is a simplified version of that used for part 1

#+begin_src swift
  func rating(_ grid: Grid<Int>, start: Cell) -> Int {
    var count = 0
    var queue = Deque<Cell>([start])

    while !queue.isEmpty {
      let cursor = queue.removeFirst()

      guard let cursorValue = grid.element(cursor),
            cursorValue != 9
      else {
        count += 1
        continue
      }

      let neighbours = grid
        .neighbours(cursor, includeDiagonals: false)
        .filter { grid.element($0)! - cursorValue == 1 }
      queue.append(contentsOf: neighbours)
    }

    return count
  }
#+end_src

#+begin_src swift
  func part2() async throws -> Int {
    trailHeads(grid).map { rating(grid, start: $0) }.reduce(0, +)
  }
#+end_src

*** Tidying Up
The code is so similar that I rewrote it to a single function. The full solution is on Github{{{sidenote(https://github.com/Abizern/aoc-swift-2024/blob/main/Sources/Day10.swift)}}}.

#+begin_src swift
  func trailCount(_ grid: Grid<Int>, start: Cell, allPaths: Bool = false) -> Int {
    var count = 0
    var queue = Deque<Cell>([start])
    var ends = Set<Cell>()

    while !queue.isEmpty {
      let cursor = queue.removeFirst()
      let cursorValue = grid.element(cursor)!

      if cursorValue == 9 {
        switch (allPaths, ends.contains(cursor)) {
        case (false, false):
          count += 1
          ends.insert(cursor)
        case (false, true):
          continue
        case (true, _):
          count += 1
          continue
        }
      }

      let neighbours = grid
        .neighbours(cursor, includeDiagonals: false)
        .filter { grid.element($0)! - cursorValue == 1 }
      queue.append(contentsOf: neighbours)
    }

    return count
  }
#+end_src

Which takes a flag that controls whether unique paths are counted or all paths.

And the original functions can be rewritten to use this more general function:

#+begin_src swift
  func score(_ grid: Grid<Int>, start: Cell) -> Int {
    trailCount(grid, start: start)
  }

  func rating(_ grid: Grid<Int>, start: Cell) -> Int {
    trailCount(grid, start: start, allPaths: true)
  }
#+end_src

I'm not sure what the final part of the puzzle is about -- why is the reindeer making flags? Maybe this problem will appear later on in the series?

** Advent of Code Day9: Disk Fragmenter               :advent_of_code:swift:
:PROPERTIES:
:EXPORT_FILE_NAME: aoc-day9-disk-fragmenter
:EXPORT_DATE: 2024-12-09
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :meta true :math false
:END:
#+begin_description
I should have read the question properly ☹️
#+end_description

I had a bit of difficulty today{{{sidenote(https://adventofcode.come/2024/day/9)}}} for two reasons. Firstly, Swift doesn't seem to be that good with deep recursions. I wanted to use a recursive solution, but my stack size grow too large. Secondly, I didn't read the requirements for part 2 properly, and it took me a while to figure out how to bubble files up into the empty slots.

I eventually got it done with an imperative loop{{{sidenote(https://github.com/Abizern/aoc-swift-2024/blob/main/Sources/Day09.swift)}}}

*** Part 1
Given a representation for a file system with file blocks and empty spaces, we are supposed to move files from the back into the empty spaces in the front and calculate a checksum.

I created a type to represent either a file block or a space, and this turned out to be helpful for part 2:

#+begin_src swift
  enum Descriptor: Equatable, CustomStringConvertible {
    case file(id: Int, length: Int)
    case empty(length: Int)

    var expanded: [Int] {
      switch self {
      case .file(let id, let length):
        Array(repeating: id, count: length)
      case .empty(let length):
        Array(repeating: Int.min, count: length)
      }
    }

    var fileId: Int {
      switch self {
      case .file(id: let id, length: _):
        id
      case .empty(length: _):
        Int.min
      }
    }

    var length: Int {
      switch self {
      case .file(_, let length):
        length
      case .empty(let length):
        length
      }
    }
  }
#+end_src

This meant that the input was an array of these =Descriptors=

I expanded my list into a list of numbers that matches the examples by using the =expanded= var on my type. Then I read from both ends of this list, if there was a space in the front, I appended the last value that was not a space in it's place. I didn't keep track of the spaces at the end, because they did not contribute to the checksum.

#+begin_src swift
  func rearrange(_ input: Deque<Int>) -> [Int] {
    var input = input
    var accumulator: [Int] = []
    while let f = input.popFirst() {
      if f > Int.min {
        accumulator.append(f)
      } else if !input.isEmpty {
        accumulator.append(input.popLast()!)
        // Clear out spaces from the back
        while !input.isEmpty, input.last! == Int.min {
          input.removeLast()
        }
      } else {
        continue
      }
    }

    return accumulator
  }
#+end_src

I then had a simple function to calculate the checksum

#+begin_src swift
  func checksum(_ input: [Int]) -> Int {
      input.enumerated().map(*).reduce(0, +)
    }
#+end_src

and the entire solution was just putting these together:

#+begin_src swift
  func part1() async throws -> Int {
    let files = Deque(diskMap.flatMap(\.expanded))
    let rearranged = rearrange(files)

    return checksum(rearranged)
  }
#+end_src

*** Part 2
This is where I got stuck for a while. Rather than trying to move each fileID once, after every movement of a file block I tried to move the files at the back into any possible new spaces that were made available by the files being moved.

After I went through the example again, I kept track of the current fileID I was trying to move, but all my recursive code seemed to overrun the stack. I'm not sure if I was writing badly recurring code, or whether Swift not being optimised for recursion is an issue. I eventually managed to get my solution to work and my choice of data structure helped.

I run through the fileIDs in reverse, I find the length of the block to move, and then look for free space at the front. If it exists, I replace the old position with empty space and insert the the fileIDs in the space. If there is more space left over, I fill that with an empty block. Then I try the next lowest FileID.

When the fileID becomes =1= I return the list since the =0= files are at the front by definition.

#+begin_src swift
  unc defrag(_ input: [Descriptor]) -> [Descriptor] {
    var input = input[...]
    var highestIndex = input.last!.fileId

    while highestIndex > 0 {
      guard let candidateIndex = input.firstIndex(where: { $0.fileId == highestIndex }) else { fatalError("We should have fileID \(highestIndex)") }
      let candidateLength = input[candidateIndex].length

      guard let targetIndex = input.firstIndex(
        where: { descriptor in
          if case .empty(let length) = descriptor, length >= candidateLength {
            true
          } else {
            false
          }
        }
      ),
        targetIndex < candidateIndex
      else {
        highestIndex -= 1
        continue
      }

      input.replaceSubrange(candidateIndex ... candidateIndex, with: [.empty(length: candidateLength)])
      let targetLength = input[targetIndex].length
      let newTarget = Descriptor.file(id: highestIndex, length: candidateLength)
      if targetLength == candidateLength {
        input.replaceSubrange(targetIndex ... targetIndex, with: [newTarget])
      } else {
        input.replaceSubrange(targetIndex ... targetIndex, with: [newTarget, .empty(length: targetLength - candidateLength)])
      }

      highestIndex -= 1
    }

    return Array(input)
  }
#+end_src

Once that is working, it's just a procedure to get the final result:

#+begin_src swift
  func part2() async throws -> Int {
    defrag(diskMap)
      .flatMap(\.expanded)
      .map { $0 > Int.min ? $0 : 0 }
      .enumerated()
      .map { $0 * $1 }
      .reduce(0, +)
  }
#+end_src

And this still ran fairly quickly: in about 0.2s which is good enough.

*** Final thoughts
Recursion didn't work and it bothers me. When I get some time I'll try it in a different language to see if it works better there.

Reading the question is important. I'm usually diligent about it, but for some reason I was so concerned about my recursive code not working that I didn't think that maybe I was solving the wrong problem.

** Advent of Code Day8: Resonant Collinearity         :advent_of_code:swift:
:PROPERTIES:
:EXPORT_FILE_NAME: aoc-day8-resonant-collinearity
:EXPORT_DATE: 2024-12-08
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :meta true :math false
:END:
#+begin_description
Maybe this explains my spotty WiFi coverage
#+end_description

We are given a grid of antennas{{{sidenote(https://adventofcode.come/2024/day/8)}}} and we're supposed to find which ones line up and find points that extend from them, and count the unique positions where they occur.

There aren't that may points. I wrote, what I thought was a quick and dirty solution, but both parts ran in about 1ms, so I didn't think it was worth doing much cleaning up.

I'm not going to show the code here, if you'd like to see it, the solution is online{{{sidenote(https://github.com/Abizern/aoc-swift-2024/blob/main/Sources/Day08.swift)}}}. I'll concentrate on the reasoning.


*** Part 1
To find an antinode between two antennas of the same time, work out the changes to the rows and columns to get to =target= from =source= and add that offset to =target=

I parsed out the antennas, and used the Swift-Algorithms package{{{sidenote(https://github.com/apple/swift-algorithms)}}} to generate a product of this list. Which gave me a pair of every antenna with every other antenna.

Each pair is a =(source, target)= pair.

If both antennas are the same, ignore the pair.

If the antennas are of different types ignore the pair.

Work out the offset between the two antennas: the change in row and column to get to =target= from =source=.

add this offset to =target= to get the antinode along the line from =source= to =target=

Check that this antinode is within the boundary otherwise ignore it.

I only check for the antinode in one direcion. Since I am taking a product of every node with every other node, the antinode in the opposite direction when I eventually examine =(target, source)=.

After I get these, I throw them in a set to remove duplicates and then count the set to get the result.

*** Part 2
There are two differences that need to be accounted for:

- Antinodes are produced all along the line to the boundaries.
- Antennas on the same line are also antinodes.

To take account of this:

For each pair I add the =source= point to the list of antinodes returned. I only add source, because the =target= antenna will be considered when I eventually examine the transposed pair.

Rather than add the offset once, I keep adding offsets while they remain with the bounds.

After I get these, I create sets from the results and combine them to remove duplicates and count them. This also took less than 1ms

*** Notes
Both solutions ran in under 1ms. There are days when I come up with a quick solution to part 1 just so that I can get on to part 2. After than I try and refactor the two solutions. Both parts ran fast enough today that I don't feel it's necessary.

I expected a harder problem for the first weekend, but I'm okay being proved wrong, I'm sure those days are coming.

** Advent of Code Day7: Bridge Repair                 :advent_of_code:swift:
:PROPERTIES:
:EXPORT_FILE_NAME: aoc-day7-bridge-repair
:EXPORT_DATE: 2024-12-07
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :meta true :math true
:END:
#+begin_description
It's turtles all the way down.
#+end_description

Recursion can make your head hurt, but it can simplify some classes of problems once you get used to the idea of turtles{{{sidenote(https://en.wikipedia.org/wiki/Turtles_all_the_way_down)}}} all the way down.

Today{{{sidenote(https://adventofcode.com/2024/day/7)}}} was about trying to validate lists of numbers according to simple rules.

It isn't possible to just insert all combinations of the operators, because for 2 numbers there are 2 possibilities. For 3 numbers there are 4 possibilities. For 4 numbers 8. Essentially: it's $\mathcal{O}(2^{n-1})$ which grows really quickly. A quick look at the input shows that some lines have 10 values. So A recursive solution which fails quickly is a better idea.

If I had read the question properly and understood the meaning of *always evaluated left-to-right* I might have saved myself some trouble.

I don't normally include a lot of tests in my solutions - I test the parsing and the example answers, and the correct result is another test. That's usually enough. My solution{{{sidenote(https://github.com/Abizern/aoc-swift-2024/blob/main/Sources/Day04.swift)}}} I had to write tests{{{sidenote(https://github.com/Abizern/aoc-swift-2024/blob/main/Tests/Day07Tests.swift#L22-L35)}}} for my validation code, which pointed out that I was taking numbers from the wrong end.

*** Part 1
There are only two operations that can be applied to successive numbers, addition and subtraction.

So I extracted each row into a convenient type with an internal check for validity:

#+begin_src swift
  struct Calibration: Equatable, Sendable {
    let target: Int
    let values: [Int]

    var isValid: Bool {
      // ...
    }
  }
#+end_src

And the answer is a filter, map and reduce:
#+begin_src swift
  func part1() async throws -> Int {
    calibrations.filter(\.isValid).map(\.target).reduce(0, +)
  }
#+end_src

The thought process with recursion is to consider:

 - The base case
 - if the base condition is not reached, how do we construct the next check?

 Since we are starting with a list of values, the base case is going to be either the empty array, or a single value. We are checking that the single value is equal to the target value. If it is we return =true=

 If we haven't reached the base case, we want to see whether multiplication or addition can by inserted before the last value {{{marginnote(By habit I was taking values from the front of the list when I should have been taking them from the end. Since operators apply left to right, the operator is being applied to the left of the value.)}}}

 To check if multiplication works, we see if the target value is a whole multiple of the last value.

 To check if addition works, we see if the target value is bigger than the last value.

 So there are two possibilities to check if we aren't at the base case. Recursion means calling the same function again with new parameters that will get closer to the base case. So we check them both, and if either of them is true, the entire check is true: The test operation is encoded in the new target, we either divide by or subtract the last value in the list:
 
 #+begin_src swift
   var isValidWithConcoatenation: Bool {
      canConcatenate(target, values: values[...])
    }

    private func canMakeTarget(_ target: Int, values: Array<Int>.SubSequence) -> Bool {
      var values = values
      guard let nextValue = values.popLast() else { fatalError("Out of bounds") }
      guard values.count > 0 else { return target == nextValue }

      let branch1 = target % nextValue == 0 && canMakeTarget(target / nextValue, values: values)
      let branch2 = target > nextValue && canMakeTarget(target - nextValue, values: values)

      return branch1 || branch2
    }
 #+end_src

 Since this is an OR check, if branch1 passes there is no need to check branch2. Inlining the two checks was marginally faster, but I prefer the readability of having the two branches.

*** Part 2

With the new operation of concatenation it's a little bit trickier. But the same technique applies as wit the first part.

The base case for concatenation is that the string representation of the target ends with the string representation of the last value. And the inverse to apply to the new target is to remove the number from the suffix. The new validation functions are:

#+begin_src swift
  var isValidWithConcoatenation: Bool {
    canConcatenate(target, values: values[...])
  }

  private func canConcatenate(_ target: Int, values: Array<Int>.SubSequence) -> Bool {
    var values = values
    guard let nextValue = values.popLast() else { fatalError("Out of bounds") }
    guard values.count > 0 else { return target == nextValue }

    let strTarget = String(target)
    let strNextValue = String(nextValue)

    let branch1 = target % nextValue == 0 && canConcatenate(target / nextValue, values: values)
    let branch2 = target > nextValue && canConcatenate(target - nextValue, values: values)
    let branch3 = strTarget.count > strNextValue.count
      && strTarget.hasSuffix(strNextValue)
      && canConcatenate(strTarget.remove(strNextValue), values: values)

    return branch1 || branch2 || branch3
  }

  // Convenience extension
  extension String {
    func remove(_ suffix: String) -> Int {
      let suffixLCount = suffix.count
      let newStr = self[..<index(endIndex, offsetBy: -suffixLCount)]
      return Int(newStr)!
    }
  }
#+end_src



The trick here is to realise that it only applies when there are two values left to check: for example:

=1319: 13 19=

Using the using =branch3= this would recurse with:

#+begin_src swift
  canConcatenate(13, values: [19])
#+end_src

And we don't need to do any specific checks because we've reached the base case of a single value that matches the target. That's why the check for branch3 is that the target has more digits that the value at the end of the list.


** Advent of Code Day6: Guard Gallivant               :advent_of_code:swift:
:PROPERTIES:
:EXPORT_FILE_NAME: aoc-day6-guard-gallivant
:EXPORT_DATE: 2024-12-06
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :meta true :math false
:END:
#+begin_description
💂‍♀️ Please don't touch the reins: The elves may bite!
#+end_description

Another{{{sidenote(https://adventofcode.com/2024/day/6)}}} grid traversal and the longest solution{{{sidenote(https://github.com/Abizern/aoc-swift-2024/blob/main/Sources/Day06.swift)}}} I've had to write so far.

Not just the longest solution; my first attempt at part 2 took around 6s to run, I managed to get this to around 0.5s. Maybe I could be more efficient, maybe I'm missing the trick to make this faster.

There isn't much to say about the solutions, so I'll keep those sections short: there is a link to my solution if you want to see the details. The interesting part is making it run faster, since I couldn't make it more efficient, I went for running it concurrently.

Frankly, I don't really like the code for my solution. There's some repetition, and I'm traversing the graph with a loop rather than being recursive and it just seems clunky.  But that's okay. This isn't code for work and there are bound to be days when I'm not really feeling it. I can always go back to it later{{{marginnote(Unlikely that I will, though. But it's the thought that counts.)}}}

Not helped by my constantly writing =guard= as a variable name which I shouldn't do in swift because it's a reserved word. I know I can escape such variables with backticks, but I didn't think my variable name was crucial enough to have to do that.

*** Part 1
Find all the positions that the guard visits.

This is really just a case of following the rules of movement, keeping a set of positions visited and then returning the count.

*** Part 2
I couldn't think of a clever algorithm for this. Just to get an answer done went through every location that the guard visited and put an obstacle there, then ran the path to see if it looped, or if the guard could leave the grid. To check for a loop, I checked the position of the guard and the direction. If that was already in the set of visited positions, I took it to be a loop, because the same path would continue to be followed.

Since only one obstacle could be added, it would have to be in one of the places that the guard visited, so that reduced the size of the search set.

This was good enough to get me an answer.

*** Making things faster
My first attempt ran okay and gave me the correct answer an about 6 seconds. That's not too bad, but it's a little annoying. Sometimes I run all my solutions at once, and a big stall in the middle of the output would annoy me.

I tried to make things faster by checking if there was an obstacle in the new path {{{sidenote(If there isn't an obstacle, then the path would lead off the grid straight away)}}}. That was a little faster, running in around 4-5 seconds. Better, but not by much.

Normally, I wouldn't try and solve these problems in parallel. There are many operations, but they are short, there are just lots of them. But I don't have to run them all individually, I can run chunks of them individually. Playing around with various sizes for the chunks give me these estimates for Part 2

| Chunk Size | Part 2 time (s) |
|------------+-----------------|
|          1 |              42 |
|         10 |             3.3 |
|         30 |             0.6 |
|         50 |             0.5 |
|        100 |             0.5 |
|        200 |             0.5 |
|        ... |             ... |

And it plateaued at around 0.5s. Not as fast as the other solutions so far this year, but 10 times faster than not using concurrency.

*** Final Thoughts
- We're starting to see the outline of the image on the main page - it looks like it could be the number 10, containing various other images from the previous years puzzles.
- I wasn't too enthused by today's challenge. I got a solution with some quick and dirty code and came back to it on and off during the day to see if I could do it better.
- Writing these daily summaries is working out to keep me working on the puzzles in a reasonable time. I wanted to get a better solution before writing this. I may have postponed it otherwise.
- The next two days are weekends, and from past experience, that's when things start getting harder.



** Advent of Code Day5: Print Queue                   :advent_of_code:swift:
:PROPERTIES:
:EXPORT_FILE_NAME: aoc-day5-print-queue
:EXPORT_DATE: 2024-12-05
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :meta true :math false
:END:
#+begin_description
PC Load Letter?! What 🤬 does that mean?
#+end_description

I made a couple of mis-steps that slowed me down a little.

This was another day{{{sidenote(https://adventofcode/2024/day/5)}}} where part 2 wasn't as much of a jump in difficulty, but needed careful reading; only add the middle values for lists that need sorting. You can see my full solution on Github{{{sidenote(https://github.com/Abizern/aoc-swift-2024/blob/main/Sources/Day05.swift)}}}.

*** Part 1
Validate a list of numbers given a set of rules.

I first tried to read the rules into a dictionary of =[Int: [Int]]= for each page, show the pages that are supposed to come after it. That failed my tests because it didn't take into account for the requirement that the rules imply a negative. If =A|B= then =B= must come after =A= and if =B= comes before =A= then the list is not valid. So both cases need to be encoded into the check.

Since =(Int, Int)= is not =Hashable= I created a small struct to encode first and last values and then use that as the key for my dictionary.

#+begin_src swift
  struct Pair: Hashable {
    let first: Int
    let second: Int

    init(_ first: Int, _ second: Int) {
      self.first = first
      self.second = second
    }
  }
#+end_src

Then I created a function to iterate through the rules, encoding the correct order as =true= and the reverse condition as =false=

#+begin_src swift
  func ordering(_ rules: [(Int, Int)]) -> [Pair: Bool] {
    var dict: [Pair: Bool] = [:]
    dict.reserveCapacity(rules.count * 2)
    for (first, second) in rules {
      dict[Pair(first, second)] = true
      dict[Pair(second, first)] = false
    }

    return dict
  }
#+end_src

The tricky part is the validation function. Since I knew that I was going to be mapping over the input list using the ordering, I wrote a function that returns the function to be used. Closures are first-class types in Swift, and this frequently makes code clearer at the call site:

#+begin_src swift
  func isValidFuntion(_ ordering: [Pair: Bool]) -> ([Int]) -> Bool {
    { pages in
      let pageCount = pages.count
      for i in 0 ..< pageCount - 1 {
        for j in i + 1 ..< pageCount {
          let pair = Pair(pages[i], pages[j])
          if ordering[pair] ?? true {
            continue
          } else {
            return false
          }
        }
      }
      return true
    }
  }
#+end_src

This goes through the list by creating every possible pair of orderings, if they are allowed or not encoded, then it is a valid pairing. If it is specifically disallowed, then I return false without checking the rest of the list.

To get the answer I filtered for valid lists, found the midpoint using:

#+begin_src swift
  func middleValue(_ list: [Int]) -> Int {
    list[list.count / 2]
  }
#+end_src

Note, =Int= division in swift means I don't have to worry about flooring the result.

After finding the midpoint, I just summed them up.
#+begin_src swift
  func part1() async throws -> Int {
    let (rules, pages) = parsedInput
    let ordering = ordering(rules)

    return pages
      .filter(isValidFuntion(ordering))
      .map(middleValue)
      .reduce(0, +)
  }
#+end_src

*** Part 2
If the list is invalid we should sort it, find the middle value and sum those values.

For lists in Swift, you can pass in a function to use for the comparison of two values, returning =true= if they are correctly ordered. As with the first part, I wrote a function that returned a sorting function:

#+begin_src swift
  func sortingFunction(_ ordering: [Pair: Bool]) -> ((Int, Int) -> Bool) {
    { first, second in
      ordering[Pair(first, second)] ?? true
    }
  }
#+end_src

Since I already have a dictionary of what should come before what, I just used that dictionary. After that the solution was trivial:

#+begin_src swift
 func part2() async throws -> Int {
    let (rules, pages) = parsedInput
    let ordering = ordering(rules)

    return pages
      .filter(isInvalidFuntion(ordering))
      .map { $0.sorted(by: sortingFunction(ordering)) }
      .map(middleValue)
      .reduce(0, +)
  }
#+end_src

*** Final Thoughts
- This wasn't as fiddly as I thought it would be once I correctly encoded the rules.
- My parsing code is taking up more and more space in my solutions, I really should extract them out to a utility library.


** Advent of Code Day4: Ceres Search                  :advent_of_code:swift:
:PROPERTIES:
:EXPORT_FILE_NAME: aoc-day4-ceres-search
:EXPORT_DATE: 2024-12-04
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :meta true :math false
:END:
#+begin_description
I love the smell of Graph Theory in the morning. It smells like — coffee.
#+end_description

Today{{{sidenote(https://adventofcode.com/2024/day/4)}}} wasn't so much about graph theory once you read the questions, but I took a similar approach to solving the problem. Parsing was trivial; just read a nested array of Characters.

My solution can be found on Github{{{sidenote(https://github.com/Abizern/aoc-swift-2024/blob/main/Sources/Day04.swift)}}}

*** Part 1
The word search game is about finding the word "XMAS" in any direction.

I used a simple search to get the positions of the Character "X" as a tuple, as my start positions.

With an enum to specify directions as compass points: North, North East, West etc
#+begin_src swift
  enum Direction: Equatable, CaseIterable {
    case n, ne, e, se, s, sw, w, nw // Compass points
  }
#+end_src

Then I created a type to represent candidates:

#+begin_src swift
  struct Candidate {
    let partial: String
    let direction: Direction
    let position: (Int, Int)
    var isValid: Bool {
      partial == "XMAS"
    }
  }
#+end_src

To start with, given a position for an "X" I created all possible candidates and put them in an array. This is what I meant when I said I took a graph theoretical approach, don't check the point, just add it to a list to check later. I did this with a method:

#+begin_src swift
  struct Candidate {
    // ...
    static func initial(row: Int, col: Int) -> [Candidate] {
      var accumulator = [Candidate]()
      for direction in Direction.allCases {
        accumulator.append(Candidate(partial: "X", direction: direction, position: (row, col)))
      }
      return accumulator
    }
  }
#+end_src

Now I can use this to create an array of all the starting points with their directions to search.

#+begin_src swift
  func countOccurrencesAround(_ position: (Int, Int), rows: [[Character]]) -> Int {
    var count = 0
    let dimensions = (width: rows[0].count, height: rows.count)
    var candidates = Candidate.initial(row: position.0, col: position.1)[...]

    while let candidate = candidates.first {
      var newCandidates = candidates.dropFirst()
      if candidate.isValid {
        count += 1
        candidates = candidates.dropFirst()
      } else {
        if let next = candidate.next(rows: rows, dimensions: dimensions) {
          newCandidates.append(next)
        }
      }
      candidates = newCandidates
    }

    return count
  }
#+end_src

For each candidate in this list, if it is valid, I increment the count of found words. If it is not valid, I try to create a new candidate, by adding a value in the search direction to the list. This creation method is long winded, but it's easy to write by following a process:

#+begin_src swift
  struct Candidate {
    // ...

    func next(rows: [[Character]], dimensions: (width: Int, height: Int)) -> Candidate? {
      guard "XMAS".hasPrefix(partial) else { return nil }

      var newRow = position.0
      var newCol = position.1
      switch direction {
      case .n:
        guard position.0 > 0
        else { return nil }
        newRow = position.0 - 1
      case .ne:
        guard position.0 > 0,
              position.1 < dimensions.height - 1
        else { return nil }
        newRow = position.0 - 1
        newCol = position.1 + 1
      case .e:
        guard position.1 < dimensions.width - 1
        else { return nil }
        newCol = position.1 + 1
      case .se:
        guard position.0 < dimensions.width - 1,
              position.1 < dimensions.height - 1
        else { return nil }
        newRow = position.0 + 1
        newCol = position.1 + 1
      case .s:
        guard position.0 < dimensions.height - 1
        else { return nil }
        newRow = position.0 + 1
      case .sw:
        guard position.0 < dimensions.width - 1,
              position.1 > 0
        else { return nil }
        newRow = position.0 + 1
        newCol = position.1 - 1
      case .w:
        guard position.1 > 0
        else { return nil }
        newCol = position.1 - 1
      case .nw:
        guard position.0 > 0,
              position.1 > 0
        else { return nil }
        newRow = position.0 - 1
        newCol = position.1 - 1
      }

      let value = rows[newRow][newCol]
      let newPartial = partial + String(value)
      return Candidate(partial: newPartial, direction: direction, position: (newRow, newCol))
    }
  }
#+end_src

If the current partial string is not part of "XMAS" I return nil

If it is, then after some wordy checks to make sure the next search position is within the bounds of the grid I create a new candidate and add that to the end of the list.

By the time the list is empty, I've searched all valid candidates around the start position and I can return the count.

To get the answer, I map this function to each start point and sum the results:

#+begin_src swift
func countOccurences(_ rows: [[Character]]) -> Int {
    let starts = findStarts("X", rows: rows)
    let count = starts.map {
      countOccurrencesAround($0, rows: rows)
    }.reduce(0, +)

    return count
  }
#+end_src

And that's it for the first part.

*** Part 2
This is simpler than part 1. I followed a similar method to part 1 by first finding all the possible start positions --- an "A" character.

#+begin_src swift
  func hasCross(_ position: (Int, Int), rows: [[Character]], dimensions: (width: Int, height: Int)) -> Bool {
    let row = position.0
    let col = position.1
    var result = false

    guard (1 ..< dimensions.width - 1).contains(row),
          (1 ..< dimensions.height - 1).contains(col)
    else { return false }

    let ne = rows[row + 1][col + 1]
    let se = rows[row + 1][col - 1]
    let sw = rows[row - 1][col - 1]
    let nw = rows[row - 1][col + 1]

    switch (nw, se) {
    case ("M", "S"):
      if (sw == "M" && ne == "S") || (sw == "S" && ne == "M") { result = true }
    case ("S", "M"):
      if (sw == "M" && ne == "S") || (sw == "S" && ne == "M") { result = true }
    default: result = false
    }
    return result
  }
#+end_src

First, I make sure that the start position is at least one row and column in from the edge, and then I check the diagonally opposite corners. If one contains M the other must contain an S and vice-versa, I do this for both sets of corners, and if both checks pass then the position has a valid "X-MAS"

To get the solution I map this function onto the list of start points, filter them for validity and return the count.

#+begin_src swift
  func countCrosses(_ rows: [[Character]]) -> Int {
    let dimensions = (width: rows[0].count, height: rows.count)
    let starts = findStarts("A", rows: rows)
    let count = starts.map {
      hasCross($0, rows: rows, dimensions: dimensions)
    }.filter { $0 }.count

    return count
  }
#+end_src

*** Final Thoughts
- A recursive solution for each start point would have been an option, but I saw a grid and thought "graph theory" so I went with this method.
- For previous Advents, I've used different languages, and created a small library of utility functions. Perhaps now is the time to do it for my Swift solutions. I want to write some common parsers, and maybe a =Grid= type would have been useful for wrapping bounds-checks and getting neighbouring positions would have made this a little shorter.



** Advent of Code Day3: Mull It Over                  :advent_of_code:swift:
:PROPERTIES:
:EXPORT_FILE_NAME: aoc-day3-mull-it-over
:EXPORT_DATE: 2024-12-03
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :meta true :math false
:END:
#+begin_description
Only day 3 and I'm already feeling inadequate 🙁
#+end_description

Normally it takes a few more days before I feel my Advent of Code inadequacy, but it struck on day 3{{{sidenote(https://adventofcode.com/2024/day/3)}}} instead. Parsing the input into a data structure that I could work with was the hardest part of today's challenge.

I try to use the Swift-Parsing package{{{sidenote(https://github.com/pointfreeco/swift-parsing/)}}} because I like the way it works, and also as an excuse to get better at using it. My first attempts at using it for Part 1 failed, so rather than bang my head any longer than I needed to, I resorted to using Swift's new =Regex= functionality. This way I could get to see what part 2 looked like and have an idea of all the parsing requirements for the challenge.

Leaving aside the parsing for now, I'll discuss my solutions{{{sidenote(The full solution I came up with is available on https://github.com/Abizern/aoc-swift-2024/blob/main/Sources/Day03.swift)}}}

*** Part 1
The challenge is to check for substrings in a particular form from which 2 numbers can be extracted. These numbers were to be multiplied and summed together.

After extracting the pairs to be multiplied, I just used my old friend =reduce= to multiply the numbers and sum them.

#+begin_src swift
  func part1() async throws -> Int {
    pairs.map { a, b in a * b }.reduce(0, +)
  }
#+end_src

*** Part 2
As well as checking for the numbers to multiply as in part 1, there is an additional check to see whether the numbers could be multiplied or not, which is done by checking for a switch in the string being parsed.

This may have been possible with Regular Expressions, but I had my heart set on using Swift-Parsing. I defined a type to match the relevant substrings:

#+begin_src swift
  enum Instruction: Equatable {
    case mul(Int, Int)
    case enabled
    case disabled

    var value: Int {
      switch self {
      case .mul(let a, let b): a * b
      case .disabled: 0
      case .enabled: 0
      }
    }
  }
#+end_src

I used value to return the multiplication when there are two numbers, and 0 for the other cases, because they do not affect the sum.

After parsing out the useful information into a list, I reduce the list keeping track of whether the switch has been enabled or disabled to include calculations:

#+begin_src swift
  func part2() async throws -> Int {
    instructions.reduce(into: (0, Instruction.enabled)) { accumulator, instruction in
      let sum = accumulator.0
      let state = accumulator.1

      switch instruction {
      case .enabled:
        accumulator = (sum, .enabled)
      case .disabled:
        accumulator = (sum, .disabled)
      case .mul:
        if state == .enabled {
          accumulator = (sum + instruction.value, .enabled)
        }
      }
    }.0
  }
#+end_src

A little long winded, but it's clear in its intent. At least to me it is.

*** Parsing
so the initial parsing done with Regular expressions:

#+begin_src swift
  func parseInput() -> [(Int, Int)] {
    let pattern = #/mul\((\d+),(\d+)\)/#

    return data
      .matches(of: pattern)
      .map { match -> (Int, Int)? in
        if let a = Int(match.output.1), let b = Int(match.output.2) {
          return (a, b)
        }
        return nil
      }.compactMap { $0 }
  }
#+end_src

  Now that I look at it, it doesn't look that bad.

  Using Swift-Parsing is more verbose. First I had to define the Parsers:

  #+begin_src swift
    struct MulParser: Parser {
      var body: some Parser<Substring, Instruction> {
        Parse(Instruction.init) {
          "mul("
          Int.parser()
          ","
          Int.parser()
          ")"
        }
      }
    }

    struct InstructionParser: Parser {
      var body: some Parser<Substring, Instruction> {
        OneOf {
          MulParser()
          "don't()".map { _ in Instruction.disabled }
          "do()".map { _ in Instruction.enabled }
        }
      }
    }
  #+end_src

  Then a parsing function:

  #+begin_src swift
    func parseInput() -> [Instruction] {
    var result = [Instruction]()
    var data = data[...]
    while !data.isEmpty {
      if let pair = try? InstructionParser().parse(&data) {
        result.append(pair)
      } else {
        data = data.dropFirst()
      }
    }
    return result
  }
  #+end_src

  Which is stepping through the entire string, dropping a character at a time and checking to see if the required pattern can be parsed off the front of the string.

  I find this deeply unsatisfying: There should be a way to do this without having to be so explicit. But for now I'll leave it as one of my challenges for the New Year.

  Only 3 days in and I'm struck by my lack of understanding of something. That's not necessarily a bad thing --- Finding out what I don't know is one of the reasons I do Advent of Code.



** Advent of Code Day2: Red-Nosed Reports             :advent_of_code:swift:
:PROPERTIES:
:EXPORT_FILE_NAME: aoc-day2-red-nosed-reports
:EXPORT_DATE: 2024-12-02
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :meta true :math true
:END:
#+begin_description
Use the (brute) force, Luke.
#+end_description

Today's{{{sidenote(https://adventofcode.com/2024/day/2)}}} challenge was only slightly more complicated than yesterday's, and one where brute(ish) force was enough. My solution is on Github{{{sidenote(https://github.com/Abizern/aoc-swift-2024/blob/main/Sources/Day02.swift)}}}.

*** Part 1
To check if a report (a list of numbers) is safe; see if they are all increasing or all decreasing and the difference is inclusively between 1 and 3.

I used the =adjacentPairs()= method from the Swift-Algorithms package{{{sidenote(https://github.com/apple/swift-algorithms)}}} rather than =zip= to get a sequence of pairs of numbers.

After checking whether the differences should be increasing or decreasing, I made sure that all the pairs satisfied the condition by using the =allSatisfy()= method.

#+begin_src swift
  func isSafe(_ report: [Int]) -> Bool {
    guard let start = report.first,
          let end = report.last,
          start != end
    else { return false }
    let shouldIncrease = start < end ? true : false

    return report.adjacentPairs().allSatisfy { a, b in
      (shouldIncrease ? a < b : a > b) && (1 ... 3).contains(abs(a - b))
    }
  }
#+end_src

I used this to filter and count the input to get my answer.

*** Part 2
To check if a report is correctable, see if removing a single number from the list makes it safe. After a few minutes thought about complexity, I used a brute(ish) force solution.

If a report is not safe, I removed one of the numbers and checked again:

#+begin_src
  func isSafeOrCorrectable(_ report: [Int]) -> Bool {
    guard !isSafe(report) else { return true }
    let length = report.count
    var i = 0
    var correctable = false

    while i < length, !correctable {
      var arr = report
      arr.remove(at: i)
      correctable = isSafe(arr)
      i += 1
    }

    return correctable
  }
#+end_src

And, again, a filter and count gives me the answer.

*** Complexity
My completely unscientific assessment of the complexity of removing an element and checking the array again:

The =adjacentPairs()= method has $\mathcal{O}(1)$ complexity, and I'm going through the elements in a single pass which is $\mathcal{O}(n)$

Removing and checking the list again means another  $\mathcal{O}(n)$ operation, taking it up to  $\mathcal{O}(n^2)$, which is not good, but at least it's not exponential.

Looking at the full problem input there are 1000 lines, each with around 10-ish numbers. Each line will require about 100 to 1000 operations. So the full input is around 1 million operations; not a lot.

So, no need to do anything clever, and my solutions are still output in milliseconds.



** Advent of Code Day 1: Historian Hysteria           :advent_of_code:swift:
:PROPERTIES:
:EXPORT_FILE_NAME: aoc-day1-historian-hysteria
:EXPORT_DATE: 2024-12-01
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :meta true :math false
:END:
#+begin_description
Welcome to the 10th Annual Hunger Games, er, I mean: Advent of Code.
#+end_description
Advent of Code{{{sidenote(https://adventofcode.com)}}} is an advent calendar of programming problems created by Eric Wastl{{{sidenote(http://was.tl)}}}.

I've normally done these in languages that I don't use for work --- Common-lisp and Haskell. This year I am going to concentrate on using my primary language of Swift.

I created a template package{{{sidenote(https://github.com/Abizern/swift-aoc-starter-template)}}}, based on one provided by Apple, for Swift solutions.

As expected the first day's{{{sidenote(https://adventofcode.com/2024/day/1)}}} problem is fairly easy and a way to make sure that one's environment is set up correctly and works.

This is the 10th anniversary event, and since it involves a missing historian, I think there may be throwbacks to problems from previous years.

*** Parsing 
Parsing the data was nothing special: The input consisted of two numbers on a line, separated by three spaces. Each number represented an entry on the two lists so created a local variable that just returned the two lists. This follow my philosophy of not doing too much to the input for part1 because you don't know what you'll need for part2

*** Part 1
The problem is to find the difference between terms in the sorted list and sum them. The example showed that the differences were the absolute differences.

To get the solution quickly I did the natural thing of sorting the two lists, mapping the differences and summing them:

#+begin_src swift
  func part1() async throws -> Int {
    // lists is an ([Int], [Int]) of the input
    zip(lists.0.sorted(), lists.1.sorted()).map { left, right in
      abs(left - right)
    }
    .reduce(0, +)
  }
#+end_src

After I managed to solve both parts I came back to this and tried something different: rather than sorting the lists, I used the Heap structure from the Swift-Collections package{{{sidenote(https://github.com/apple/swift-collections)}}}. I initialised two heaps and used the =removeMin()= method on each to successively get the smallest value from each list:

#+begin_src swift
  func part1() async throws -> Int {
    let (left, right) = lists
    var leftHeap = Heap(left)
    var rightHeap = Heap(right)

    var result: Int = 0
    while !leftHeap.isEmpty && !rightHeap.isEmpty {
      result += abs(leftHeap.removeMin() - rightHeap.removeMin())
    }

    return result
  }
#+end_src

This may have been slightly faster.

*** Part 2
This part required counting the number of occurrences of each number in the second list. Since I had to use this as a lookup table I created a dictionary by using the handy initialiser on =Dictionary= that takes a grouping. For example, given the example list of =[4, 3, 5, 3, 9, 3]= we can get a dictionary of the groupings with:

#+begin_src swift
  Dictionary(grouping: input, by: { $0 })
  // -> [3: [3, 3, 3], 9: [9], 5: [5], 4: [4]]
#+end_src

and by mapping the values to counts we can get a lookup table for the frequencies:

#+begin_src swift
  Dictionary(grouping: input, by: { $0 }).mapValues(\.count)
  // -> [4: 1, 9: 1, 5: 1, 3: 3]
#+end_src

After that it's just a case of calculating the values and summing them, which I did in a single reduce:

#+begin_src swift
  func part2() async throws -> Int {
    let (left, right) = lists
    let counts = Dictionary(grouping: right, by: { $0 }).mapValues(\.count)

    let simililarities = left.reduce(into: 0) { partialResult, l in
      let n = counts[l, default: 0]
      partialResult += l * n
    }

    return simililarities
  }
#+end_src

The full solution is available on Github{{{sidenote(https://github.com/Abizern/aoc-swift-2024/blob/main/Sources/Day01.swift)}}}.

A simple puzzle that let me test my Swift environment, and this blog.


** Zip a Collection of Publishers                            :combine:swift:
:PROPERTIES:
:EXPORT_FILE_NAME: zip-a-collection-of-publishers
:EXPORT_DATE: 2019-09-29
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :meta true :math false
:END:
#+begin_description
I wrote a publisher that takes an array of publishers and produces a single publisher of the array of their outputs.
#+end_description

I{{{marginnote(This was originally published on my old site at [abizern.org](https://abizern.org))}}} have an array of publishers: =[Publisher<Data, Error>]= and want a publisher of the array of their outputs: =Publisher<[Data], Error>=. The Combine framework provides the =Zip= family of publishers which only go up to 4 inputs so this won't suit my needs. I'm going to write about the steps I took to create a publisher that does what I want.

This seems like a daunting task. There is a blog post about creating a [[https://danieltull.co.uk/blog/2019/08/04/combine-latest-collection/][Combine Latest publisher]] which does something similar to what I needed. I could have used that publisher, but I wanted to be more explicit that this was a =Zip= type of publisher not a =CombineLatest= type of publisher.

At a recent [[https://nscodernightlondon.com][NSCoder Night]]{{{sidenote(A monthly meetup of iOS and macOS developers)}}}, [[https://twitter.com/danielctull][Daniel]] helped me write a publisher that fetched all the pages of a paginated URL. From talking to him and referring to his write up I came to realise that creating a publisher is basically like following a recipe. And more importantly it's not the Publisher that does the work: when a publisher receives a subscription, it creates an internal =Subscription= object which it returns to the subscriber. It is this Subscription object which actually does the work.

*** Why do I Need my Own Publisher?
For an app that I am developing for a client I fetch 24 images from 24 different URLs. I need all the images, and I need them to be ordered for the resulting object that I create to be considered complete. I want to be able to write a chain a like this at the call site:

#+begin_src swift 
  urls                  // [String]
    .map(convertToURL)  // [URL]
    .map(loadURL)       // [Publisher<Data, Error>]
    .zip                // Publisher<[Data], Error>
    .sink {...}         // Consume [Data] or handle the error
#+end_src

*** Why Zip and not CombineLatest?
As the array of publishers that I have are one-shot publishers, I /could/ use the CombineLatest publisher described in the post above. There is a difference between CombineLatest and Zip. Diagrams make this clearer.

@@html:{{< figure
  src="/img/2019/09/CombineLatest.png"
  title="Marble diagram of CombineLatest"
  label="combine-latest-marble-diagram"
  caption="The _latest_ outputs of the publishers"
  attr=""
  link="/img/2019/09/CombineLatest.png"
>}}@@

@@html:{{< figure
  src="/img/2019/09/Zip.png"
  title="Marble diagram of Zip"
  label="zip-marble-diagram"
  caption="Publishes _pairs_ of outputs."
  attr=""
  link="/img/2019/09/Zip.png"
>}}@@

I chose to write the Zip publisher because conceptually, I want to wait for all the matched outputs and using a Zip makes this requirement explicit. And, I wanted an excuse to write a publisher.

*** Writing the Publisher

**** Step 1:
Create a struct which defines its =Output= and =Failure= matched to the /upstream/ =Output= and =Failure=.

Let's start with the Publisher itself. Publishers are =struct=s. In my case it's just a container to hold the array of publishers so I constrain the generic type to be a collection of publishers. I also typealias the Output to be an array of the upstream publisher's Outputs and the Failure to be the upstream publisher's Failure type.

#+begin_src swift
  public struct ZipCollection<Publishers>
    where
    Publishers: Collection,
    Publishers.Element: Publisher
  {
    public typealias Output = [Publishers.Element.Output]
    public typealias Failure = Publishers.Element.Failure

    private let publishers: Publishers

    public init(_ publishers: Publishers) {
      self.publishers = publishers
    }
  }
#+end_src

**** Step 2:
Make this struct conform to =Publisher= matching the =Output= and =Failure= to the /downstream/ =Input= and =Failure=.

Add an extension to make =ZiCollection= conform to =Publisher= and implement the required method. This will not compile yet, because the =Subscription= type hasn't been defined. Note that I'm constraining the downstream =Output= and =Failure= to =Zip='s =Output= and =Failure=. The method simply creates a =Subscription= object and passes it along to the subscriber.

#+begin_src swift
  extension ZipCollection: Publisher {
    public func receive<Subscriber>(subscriber: Subscriber)
      where
      Subscriber: Combine.Subscriber,
      Subscriber.Failure == Failure,
      Subscriber.Input == Output
    {
      let subscription = Subscription(subscriber: subscriber, publishers: publishers)
      subscriber.receive(subscription: subscription)
    }
  }
#+end_src 

**** Step 3:
Create a =Subscription= object to return to the downstream subscribers that does the work of transforming the /upstream/ =Output= and =Failure= to the /downstream/ =Input= and =Failure=

#+begin_src swift
  extension ZipCollection {
    fileprivate final class Subscription<Subscriber>: Combine.Subscription
    where
  Subscriber: Combine.Subscriber,
    Subscriber.Failure == Failure,
    Subscriber.Input == Output
    {
      private let subscribers: [AnyCancellable]
      private let queues: [Queue<Publishers.Element.Output>]
    
      init(subscriber: Subscriber, publishers: Publishers) {
        var count = publishers.count
        var outputs = publishers.map { _ in Queue<Publishers.Element.Output>() }
        queues = outputs
        var completions = 0
        var hasCompleted = false
        let lock = NSLock()
      
        subscribers = publishers.enumerated().map { index, publisher in
          publisher.sink(receiveCompletion: { completion in
            lock.lock()
            defer { lock.unlock() }
          
            guard case .finished = completion else {
              // Any failure causes the entire subscription to fail.
              subscriber.receive(completion: completion)
              hasCompleted = true
              outputs.forEach { queue in
                queue.removeAll()
              }
              return
            }
          
            completions += 1
          
            guard completions == count else { return }
          
            subscriber.receive(completion: completion)
            hasCompleted = true
          }, receiveValue: { value in
            lock.lock()
            defer { lock.unlock() }
          
            guard !hasCompleted else { return }
            outputs[index].enqueue(value)
          
            guard (outputs.compactMap{ $0.peek() }.count) == count else { return }
          
            _ = subscriber.receive(outputs.compactMap({ $0.dequeue() }))
          })
        }
      }
    
      public func cancel() {
        subscribers.forEach { $0.cancel() }
        queues.forEach { $0.removeAll() }
      }
    
      public func request(_ demand: Subscribers.Demand) {}
    }
  }
#+end_src

This is a bit more code, because this is where the actual work is being done.

The only property is an array of =AnyCancellable= which is used to handle the output of the upstream array of publishers. The =init= method configures each of these to handle the output of the upstream publishers. I use a `Queue` to hold on to the received values, and when at least one value has been received from each of the publishers, I dequeue those results and send them on to the downstream subscriber as an array.

I handle cancellation by sending a =cancel()= message to each of the =Cancellables=.

As I'm not handling back pressure there is an empty implementation of the required =request(_)= method.

*** Make it Chainable
That's it for the publisher. The only thing left to do is to write some conveniences to allow it to be used with chaining syntax. That's quite simple:

#+begin_src swift
extension Collection where Element: Publisher {
    /// Combine the array of publishers to give a single array of the `Zip ` of their outputs
    public var zip: ZipCollection<Self> {
        ZipCollection(self)
    }
}
#+end_src

*** Closing Thoughts
Is this as efficient as Combine's =Zip= functions? I Don't know. At the call site it's a lot easier to use this rather than trying to turn 24 requests into 6 batches of =Zip4= then a =Zip3= and then a =Zip2= to chain all 24 requests together (I know, because that was what I started to write). So it solves the problem I had in a way that I wanted to write the code. Also, the more of these that I write, the more comfortable I get writing them, which is another benefit.

*** Edit
Thanks to [[https://twitter.com/_iains][Iain Smith]] who messaged me to point out that cancellation didn't clear out the queues I've made some minor corrections to the code.

*** Code Repository
The code for this is available as part of the [[https://github.com/CombineHarvesters/FoundationCombine][FoundationCombine]] Swift Package available on GitHub. Alongside the =CombineLatest= publisher which inspired it.


** An Easy Answer is not Always Best                            :simplicity:
:PROPERTIES:
:EXPORT_FILE_NAME: an-easy-answer-is-not-always-best
:EXPORT_DATE: 2010-01-08
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :meta true :math false
:END:
#+begin_description
Sometimes it's better to answer the actual, unspoken question
#+end_description

On{{{marginnote(This was originally published on my old site at [abizern.org](https://abizern.org))}}} New Year's eve, Dámasa asked me to calculate some fraction of a fraction and
provide the answer as a fraction in eighths. The post had just arrived so I
flipped over an envelope and started working it out.

"Why do you need the answer in eighths?" I asked, while making calculations.

"Because I'm trying to convert a recipe and my scales only go down to eighths of an ounce."

"Why don't you just use grams?"

"…"

This reminded me of an [[https://asp-blogs.azurewebsites.net/alex_papadimoulis/408925][article]] by Alex Papadimoulis where he used the analogy of being asked whether it was better to use a bottle or a shoe to pound a nail. Although there are situations where either could be used, the real answer is, of course, to use a hammer. Sometimes we are asked questions to which we can provide an answer; but perhaps we should first stop and ask the reason for the question before answering it.

*** Lazy Questions
Let's take [[https://stackoverflow.com][StackOverflow]] as an example{{{marginnote(I'm not knocking it\, I learned to program on this site. Not by asking questions\, but through the research I did to answer questions.)}}}
The programmer's question and answer site that is also a game. 'Good' behaviour, such as asking good questions, providing helpful answers, are rewarded by upvotes, 'bad' behaviour; lazy questions, incorrect answers, are discouraged by downvotes. It is becoming increasingly common to find a Stack Overflow link as the top hit when searching the web for answers to programming questions. But, if you follow a mailing list for your chosen speciality it isn't hard to see the same question in both places and different approaches to answering them.

The site's [[https://meta.stackexchange.com/questions/19665/the-help-vampire-problem/19673#19673][recommended approach]] to the [[https://slash7.com/2006/12/22/vampires/][help vampires]] is a pragmatic one. Essentially, you can either be aloof and use the tools of the site to discourage the behaviour; or you could just answer the question and get some points. On a mailing list like, say, CocoaDev, a weak question will get sharp answers (if any); but on Stack Overflow, somebody might just answer the question because they get something out of it.

This might be useful to somebody. I'm sure there are times where we all just need a quick answer to question without deeper knowledge. Get help with the 'how' to get something done, and pick up on the 'why' later.  But read enough questions in public forums and you'll soon recognise those who just want to know the 'how', and no amount of saying they need to learn the basics is going to help. Maybe back up and ask why they are asking so you can better answer their question.

*** Relational vs Instrumental Understanding
 Richard Skemp{{{sidenote(Skemp\, Richard R. [Relational Understanding and Instrumental Understanding](https://www.jstor.org/stable/41182357). Mathematics Teaching in the Middle School\, vol. 12\, no. 2\, 2006\, pp. 88–95)}}}
 wrote on the difference between relational{{{sidenote(**Relational** understanding is knowing what to do and why.)}}}
 and instrumental{{{sidenote(**Instrumental** understanding is rote learning)}}}
 understanding. A particular example is how the invert and multiply method of fractional division is widely taught without actually developing an understanding of the operation itself. When I was 14 my elder brother taught me [[https://en.wikipedia.org/wiki/Derivative][differentiation]]. Not by saying "subtract one from the exponent and multiply", but rather by drawing a curve and working through calculating a tangent using deltas and differences tending to zero and how it led to the simpler method. I've long forgotten the hard way, but after that I was very good at calculus.

Perhaps this is something to think about next time somebody asks how to write an application without using Interface Builder in Xcode.

* About
:PROPERTIES:
:EXPORT_FILE_NAME: About
:EXPORT_HUGO_SECTION: /
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :math false 
:END:

I am a freelance iOS and macOS developer in London. Currently *available* for new contracts.

I write modern, maintainable code in Swift{{{marginnote(Of course\, I can hurt myself in other languages\, but this is what I use professionally)}}} using SwiftUI, UIKit, AppKit and a whole lotta love.

I've given talks across the UK and internationally{{{sidenote(Excuse the humblebrag)}}} and you can see a list of some of them [[/talks][here]]

I organise the monthly [[https://nscodernightlondon.com][NSCoder Night London]] meetup where iOS and macOS developers meet to chat and share knowledge and experience. This went into hiatus during the Pandemic, but we managed to keep it going by having remote meetings.

You can see my older posts at my previous site [[https://abizern.org][abizern.org]], but I'm going to keep this one just for development related topics.

** Contact
Feel{{{marginnote(Looks odd\, but this way I know the contact is coming from this site)}}} free to contact me at [[mailto://tails-rollout0s@icloud.com][tails-rollout0s@icloud.com]].

I can be found on various places online with the username of =abizern=.

I no longer use Twitter, but I can be found on Mastodon and Bluesky. {{{marginnote(The links are in the footer)}}}

I'm not on Facebook, or Threads though.

** GPG Key
Key ID: =7E2C07666BEEED1C=

Key Signature: =CF1C 8FE5 A508 0E70 4BCB  97DE 7E2C 0766 6BEE ED1C=

Key: Available on a keyserver near you, or you can [[/res/GPGKey.asc][download it]].

** Colophon

This is a static site generated{{{marginnote(The source for the site is available here https://github.com/Abizern/Abizern.github.io)}}} using [[https://gohugo.io][Hugo]] and my lightly modified version of the [[https://hugo-tufte.netlify.app][hugo-tufte]] theme.

There are no analytics being collected.

Comments are not enabled on this site. If you'd like to follow up on anything just send me an email.

* Talks
:PROPERTIES:
:EXPORT_FILE_NAME: Talks
:EXPORT_HUGO_SECTION: /
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :math false
:END:

Some of the presentations I have made at conferences and developer meet-ups over the years.

** Pull Requests are a Language
/iOSCon, London, 22nd March 2018/

Move beyond "LGTM". Pull Requests{{{speakerdeck(https://speakerdeck.com/abizern/pull-requests-are-a-language)}}}{{{skillsmatter(https://skillsmatter.com/skillscasts/11710-lightning-talk-pull-requests-are-language#video)}}} can be a way for teams to communicate more than just changes in a codebase.

** The Road to Damascus, or FRP and Me
/NSSpain, Logroño, 14th September 2017/

A talk{{{speakerdeck(https://speakerdeck.com/abizern/the-road-to-damascus-or-frp-and-me)}}}{{{marginnote([Video on NSSpain's Vimeo](https://vimeo.com/235050604))}}} given at NSSpain about my experiences of looking into using Functional Reactive Programming with RxSwift.

** Be Your Own Backend Developer
/Code Mobile, Chester, 18th April 2017/

An overview{{{speakerdeck(https://speakerdeck.com/abizern/be-your-own-backend-developer)}}} of Server Side Swift. This was recorded, but unfortunately the video isn't available.

** Safer Programming with Types
/Swift London, London, 25th October, 2016/

A short{{{speakerdeck(https://speakerdeck.com/abizern/safer-programming-with-types)}}}{{{youtube(https://www.youtube.com/watch?v=uR6ox-9VPAA&t=1s)}}} talk about type safety presented at the Swift London meetup.

** Core Data: It's not Dead Yet
/FrenchKit, Paris, 23rd September 2016/

I spoke{{{speakerdeck(https://speakerdeck.com/abizern/core-data-its-not-dead-yet)}}}{{{youtube(https://youtu.be/iOdg7WOEWWE)}}} at the first FrenchKit (now known as Swift Connection) conference about how Core Data is still relevant in the age of Swift.

** Being Imperfect in a Perfect World
/NSBarcelona, Barcelona, 21st September 2016/

I spoke{{{speakerdeck(https://speakerdeck.com/abizern/being-imperfect-in-a-perfect-world)}}} at the NSBarcelona meetup about the choices we make about the patterns we use in development.

** AltConf Post-WWDC Panel
/AltConf, San Franciso, June 2016/

I was a panel member for the AltConf post-WWDC discussion. This was recorded, but the video is no longer available.

** Swift London Pre-WWDC Panel
/Swift London, London, June 2016/

I{{{youtube(https://www.youtube.com/watch?v=PK1PPNTmGuw)}}} was a panel member for a pre-WWDC discussion. I was a late addition to this, which is my excuse for looking so scruffy.

** Dependency Management with Carthage
/CocoaHeads Stockholm, Stockholm, May 2016/

An updated{{{speakerdeck(https://speakerdeck.com/abizern/dependency-management-with-carthage)}}}{{{marginnote([Video on Vimeo](https://vimeo.com/album/3943556/video/165920026))}}} and expanded version of my previous talk about using Carthage for dependency management.

** Carthage
/NSLondon, London, 30th July, 2015/

A talk{{{speakerdeck(https://speakerdeck.com/abizern/carthage)}}} at NSLondon about using Carthage for dependency management.

** What Haskell Teaches me about Writing Swift
/AltConf, San Francisco, June 2015/

I had the{{{speakerdeck(https://speakerdeck.com/abizern/what-haskell-teaches-me-about-writing-swift)}}} opportunity to present a longer version of the lightning talk I gave at Swift Summit. These are my personal thoughts about writing Swift after knowing some Haskell.

This was recorded, but the video is no longer available.

** What Haskell Taught me about Swift
/Swift Summit, London, 21st March 2015/

A short talk{{{speakerdeck(https://speakerdeck.com/abizern/what-haskell-taught-me-about-writing-swift)}}} about how knowing Haskell helped me to better understand and learn Swift.

** Fizz Buzz in Swift
/NSLondon, London, 14th August 2014/

A talk{{{speakerdeck(https://speakerdeck.com/abizern/fizzbuzz-in-swift-a-talk-with-3-codas)}}} I gave about different approaches to solving the Fizz Buzz problem in in Swift, along with some thoughts about the new language.

This was my first mention in iOSDevWeekly.{{{sidenote([Issue 167](https://iosdevweekly.com/issues/167))}}}


** Adding 3rd Party Code to your Project
/iOSCon 2014, London, 15th May 2014/

I spoke at the first edition of iOSCon{{{speakerdeck(https://speakerdeck.com/abizern/adding-3rd-party-code-to-xcode-projects)}}}{{{skillsmatter(https://skillsmatter.com/skillscasts/5058-third-party-code)}}} covering the usage of Git and CocoaPods for adding dependencies to an Xcode project

** Distributed Version Control at LiDG 
/LiDG, London, October 2010/

A short presentation about Distributed Version Control (mainly Git) to the London iPhone Developer Group in the Regent Street Apple store.
